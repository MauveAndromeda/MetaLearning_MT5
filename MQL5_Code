//+------------------------------------------------------------------+
//|                                   HighRiskMetaLearningEA.mq5 |
//|                          é«˜é£é™©é«˜æ”¶ç›Šå…ƒå­¦ä¹ EA - EURUSDä¸“ç”¨    |
//|                                             ç›®æ ‡å¹´åŒ–ç‡>100%   |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, High Risk Trading"
#property link      "https://www.mql5.com"
#property version   "2.00"
#property description "âš ï¸ æé«˜é£é™©EA - å¯èƒ½æŸå¤±å…¨éƒ¨æœ¬é‡‘ï¼Œç›®æ ‡å¹´åŒ–>100%"

//--- åŒ…å«å¿…è¦çš„åº“
#include <Trade\Trade.mqh>

//--- æ¿€è¿›äº¤æ˜“å‚æ•°
input double BaseLotSize = 1.0;           // åŸºç¡€æ‰‹æ•°ï¼ˆå¤§å¹…æé«˜ï¼‰
input double MaxLotSize = 10.0;           // æœ€å¤§æ‰‹æ•°
input double RiskPerTrade = 0.05;         // å•ç¬”é£é™©5%ï¼ˆæé«˜ï¼‰
input int    TrainingPeriod = 900;        // 15åˆ†é’Ÿé‡è®­ç»ƒï¼ˆæ›´é¢‘ç¹ï¼‰
input double SignalThreshold = 0.55;      // é™ä½é˜ˆå€¼ï¼ˆæ›´å¤šäº¤æ˜“ï¼‰
input double ConfidenceBoost = 0.75;      // é«˜ä¿¡å¿ƒä¿¡å·é˜ˆå€¼
input int    HistoryBars = 500;           // æ›´å¤šå†å²æ•°æ®
input int    MaxPositions = 5;            // æœ€å¤§åŒæ—¶æŒä»“æ•°
input bool   UseMartin = true;            // å¯ç”¨é©¬ä¸ç­–ç•¥
input double MartinMultiplier = 1.5;      // é©¬ä¸å€æ•°
input bool   UseTrendFollow = true;       // è¶‹åŠ¿è·Ÿéš
input bool   UseScalping = true;          // å¯ç”¨å‰¥å¤´çš®
input int    ScalpingProfit = 15;         // å‰¥å¤´çš®è·åˆ©ç‚¹æ•°
input double VolatilityMultiplier = 2.0;  // æ³¢åŠ¨ç‡ä¹˜æ•°

//--- æ—¶é—´è¿‡æ»¤
input bool   TradeInAsian = false;        // äºšæ´²æ—¶æ®µäº¤æ˜“
input bool   TradeInLondon = true;        // ä¼¦æ•¦æ—¶æ®µäº¤æ˜“  
input bool   TradeInNewYork = true;       // çº½çº¦æ—¶æ®µäº¤æ˜“
input bool   TradeOverlap = true;         // é‡å æ—¶æ®µåŠ å€äº¤æ˜“

//+------------------------------------------------------------------+
//| é«˜çº§ç»“æ„ä½“å®šä¹‰                                                     |
//+------------------------------------------------------------------+
struct MarketMicrostructure {
    double price_change;
    double volume_change;
    double volatility;
    double rsi;
    double macd;
    double spread;
    double atr;
    double momentum;
    double bb_position;
    double trend_strength;
    
    MarketMicrostructure() {
        price_change = 0.0;
        volume_change = 0.0;
        volatility = 0.0;
        rsi = 0.0;
        macd = 0.0;
        spread = 0.0;
        atr = 0.0;
        momentum = 0.0;
        bb_position = 0.0;
        trend_strength = 0.0;
    }
};

struct SimpleVector {
    double data[20];  // å¢åŠ åˆ°20ä¸ªç‰¹å¾
    int size;
    
    SimpleVector() {
        for(int i = 0; i < 20; i++) {
            data[i] = 0.0;
        }
        size = 0;
    }
    
    SimpleVector(const double& value) {
        for(int i = 0; i < 20; i++) {
            data[i] = value;
        }
        size = 20;
    }
};

struct TransformerModel {
    double weights[400];      // å¢åŠ æƒé‡æ•°é‡
    double bias[20];
    double performance_score;
    bool is_trained;
    int consecutive_wins;
    int consecutive_losses;
    double confidence_level;
    
    TransformerModel() {
        for(int i = 0; i < 400; i++) {
            weights[i] = 0.0;
        }
        for(int i = 0; i < 20; i++) {
            bias[i] = 0.0;
        }
        performance_score = 0.0;
        is_trained = false;
        consecutive_wins = 0;
        consecutive_losses = 0;
        confidence_level = 0.5;
    }
};

struct AggressiveTradeManager {
    double current_lot_size;
    int trades_today;
    double daily_profit;
    double max_drawdown_today;
    bool martingale_active;
    int martingale_level;
    double last_loss_amount;
    datetime last_trade_time;
    
    AggressiveTradeManager() {
        current_lot_size = BaseLotSize;
        trades_today = 0;
        daily_profit = 0.0;
        max_drawdown_today = 0.0;
        martingale_active = false;
        martingale_level = 0;
        last_loss_amount = 0.0;
        last_trade_time = 0;
    }
};

//+------------------------------------------------------------------+
//| å…¨å±€å˜é‡                                                           |
//+------------------------------------------------------------------+
TransformerModel model;
AggressiveTradeManager trade_manager;
CTrade trade;
bool modelTrained = false;
datetime lastTrainingTime = 0;

//--- æŠ€æœ¯æŒ‡æ ‡å¥æŸ„
int rsi_handle;
int macd_handle;
int bb_handle;
int atr_handle;
int ma_fast_handle;
int ma_slow_handle;

//--- é£é™©æ§åˆ¶
double daily_max_loss;
double account_start_balance;
int magic_number = 2025001;

//--- åŠ¨é‡æ•°ç»„ï¼ˆç”¨äºæƒé‡æ›´æ–°ï¼‰
double momentum_weights[400];

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    Print("ğŸ”¥ HIGH RISK Meta-Learning EA Started - Target >100% Annual Return!");
    Print("âš ï¸  WARNING: This EA may lose 100% of capital!");
    
    // è®°å½•åˆå§‹ä½™é¢
    account_start_balance = AccountInfoDouble(ACCOUNT_BALANCE);
    daily_max_loss = account_start_balance * 0.50; // æé«˜åˆ°50%é¿å…è¿‡æ—©åœæ­¢
    
    Print("ğŸ’° Start Balance: ", account_start_balance, ", Max Daily Loss: ", daily_max_loss);
    
    // åˆå§‹åŒ–åŠ¨é‡æ•°ç»„
    for(int i = 0; i < 400; i++) {
        momentum_weights[i] = 0.0;
    }
    
    // è®¾ç½®é­”æœ¯æ•°å­—
    trade.SetExpertMagicNumber(magic_number);
    
    // åˆå§‹åŒ–äº¤æ˜“å¯¹è±¡
    if(!trade.SetTypeFillingBySymbol(_Symbol)) {
        Print("Error setting order filling type");
        return INIT_FAILED;
    }
    
    // åˆå§‹åŒ–æŠ€æœ¯æŒ‡æ ‡
    rsi_handle = iRSI(_Symbol, PERIOD_CURRENT, 8, PRICE_CLOSE);
    macd_handle = iMACD(_Symbol, PERIOD_CURRENT, 8, 21, 5, PRICE_CLOSE);
    bb_handle = iBands(_Symbol, PERIOD_CURRENT, 20, 0, 1.5, PRICE_CLOSE);
    atr_handle = iATR(_Symbol, PERIOD_CURRENT, 14);
    ma_fast_handle = iMA(_Symbol, PERIOD_CURRENT, 10, 0, MODE_EMA, PRICE_CLOSE);
    ma_slow_handle = iMA(_Symbol, PERIOD_CURRENT, 30, 0, MODE_EMA, PRICE_CLOSE);
    
    if(rsi_handle == INVALID_HANDLE || macd_handle == INVALID_HANDLE || 
       bb_handle == INVALID_HANDLE || atr_handle == INVALID_HANDLE ||
       ma_fast_handle == INVALID_HANDLE || ma_slow_handle == INVALID_HANDLE) {
        Print("âŒ Error creating indicators");
        return INIT_FAILED;
    }
    
    Print("âœ… All indicators created successfully");
    
    // ç­‰å¾…æŒ‡æ ‡æ•°æ®å°±ç»ª
    Sleep(1000);
    
    // åˆå§‹åŒ–å…ƒå­¦ä¹ å™¨
    InitializeMetaLearner();
    
    // å¼ºåˆ¶è®­ç»ƒæ¨¡å‹ï¼ˆä¸ä¾èµ–æ–‡ä»¶åŠ è½½ï¼‰
    Print("ğŸ§  Force training new model...");
    TrainModel();
    modelTrained = true; // å¼ºåˆ¶è®¾ä¸ºå·²è®­ç»ƒ
    
    Print("ğŸ¯ EA Initialized - Ready for Aggressive Trading!");
    Print("ğŸ“Š Model Status: ", modelTrained ? "TRAINED âœ…" : "NOT TRAINED âŒ");
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // æ¸…ç†èµ„æº
    IndicatorRelease(rsi_handle);
    IndicatorRelease(macd_handle);
    IndicatorRelease(bb_handle);
    IndicatorRelease(atr_handle);
    IndicatorRelease(ma_fast_handle);
    IndicatorRelease(ma_slow_handle);
    
    // æ˜¾ç¤ºäº¤æ˜“ç»Ÿè®¡
    double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double total_return = (final_balance - account_start_balance) / account_start_balance * 100;
    
    Print("ğŸ“Š Final Statistics:");
    Print("ğŸ”¹ Start Balance: ", account_start_balance);
    Print("ğŸ”¹ Final Balance: ", final_balance);
    Print("ğŸ”¹ Total Return: ", DoubleToString(total_return, 2), "%");
    Print("ğŸ”¹ Total Trades: ", trade_manager.trades_today);
    
    Print("High Risk EA deinitialized, reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                            |
//+------------------------------------------------------------------+
void OnTick() {
    // æ£€æŸ¥é£é™©æ§åˆ¶
    if(!CheckRiskLimits()) return;
    
    // æ›´æ–°äº¤æ˜“ç»Ÿè®¡
    UpdateTradingStats();
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æ–°Kçº¿
    static datetime last_bar_time = 0;
    datetime current_bar_time = iTime(_Symbol, PERIOD_CURRENT, 0);
    
    if(current_bar_time <= last_bar_time) {
        return;
    }
    last_bar_time = current_bar_time;
    
    // æ£€æŸ¥äº¤æ˜“æ—¶æ®µ
    if(!IsGoodTradingTime()) return;
    
    // ç”Ÿæˆæ¿€è¿›äº¤æ˜“ä¿¡å·
    GenerateAggressiveSignals();
    
    // ç®¡ç†ç°æœ‰æŒä»“
    ManagePositions();
    
    // é¢‘ç¹é‡æ–°è®­ç»ƒ
    if (TimeCurrent() - lastTrainingTime > TrainingPeriod && !IsTesting()) {
        TrainModel();
        lastTrainingTime = TimeCurrent();
    }
}

//+------------------------------------------------------------------+
//| æ£€æŸ¥æ˜¯å¦åœ¨æµ‹è¯•æ¨¡å¼                                                |
//+------------------------------------------------------------------+
bool IsTesting() {
    return MQLInfoInteger(MQL_TESTER);
}

//+------------------------------------------------------------------+
//| æ£€æŸ¥é£é™©é™åˆ¶                                                      |
//+------------------------------------------------------------------+
bool CheckRiskLimits() {
    double current_balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double current_equity = AccountInfoDouble(ACCOUNT_EQUITY);
    
    // æ”¾å®½é£é™©é™åˆ¶ä»¥å…è®¸æ›´å¤šäº¤æ˜“
    static bool risk_warning_shown = false;
    
    // æ£€æŸ¥å•æ—¥æœ€å¤§äºæŸï¼ˆæé«˜åˆ°50%ï¼‰
    if(account_start_balance - current_balance > daily_max_loss) {
        if(!risk_warning_shown) {
            Print("âš ï¸ Daily loss limit reached. Balance: ", current_balance, " vs Start: ", account_start_balance);
            risk_warning_shown = true;
        }
        return false;
    }
    
    // æ”¾å®½æƒç›Šæ£€æŸ¥ï¼ˆä»90%é™åˆ°70%ï¼‰
    if(current_equity < current_balance * 0.7) {
        Print("âš ï¸ High drawdown detected. Equity: ", current_equity, " vs Balance: ", current_balance);
        CloseLosingPositions();
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| æ›´æ–°äº¤æ˜“ç»Ÿè®¡                                                      |
//+------------------------------------------------------------------+
void UpdateTradingStats() {
    static datetime last_update_day = 0;
    datetime current_day = TimeCurrent() / 86400 * 86400; // å½“å¤©0ç‚¹
    
    if(current_day != last_update_day) {
        // æ–°çš„ä¸€å¤©ï¼Œé‡ç½®ç»Ÿè®¡
        trade_manager.trades_today = 0;
        trade_manager.daily_profit = 0.0;
        trade_manager.max_drawdown_today = 0.0;
        last_update_day = current_day;
        
        Print("ğŸ“… New trading day started. Statistics reset.");
    }
}

//+------------------------------------------------------------------+
//| æ£€æŸ¥äº¤æ˜“æ—¶æ®µ                                                      |
//+------------------------------------------------------------------+
bool IsGoodTradingTime() {
    // åœ¨å›æµ‹ä¸­å…è®¸æ‰€æœ‰æ—¶é—´äº¤æ˜“
    if(IsTesting()) return true;
    
    MqlDateTime dt;
    TimeToStruct(TimeCurrent(), dt);
    int hour = dt.hour;
    
    // æ”¾å®½æ—¶é—´é™åˆ¶ - å…è®¸æ›´å¤šæ—¶æ®µäº¤æ˜“
    if(!TradeInAsian && !TradeInLondon && !TradeInNewYork) {
        return true; // å¦‚æœæ‰€æœ‰æ—¶æ®µéƒ½ç¦ç”¨ï¼Œåˆ™å…è®¸äº¤æ˜“
    }
    
    // äºšæ´²æ—¶æ®µ (22:00-08:00 GMT)
    if((hour >= 22 || hour < 8) && TradeInAsian) return true;
    
    // ä¼¦æ•¦æ—¶æ®µ (08:00-16:00 GMT)  
    if(hour >= 8 && hour < 16 && TradeInLondon) return true;
    
    // çº½çº¦æ—¶æ®µ (13:00-22:00 GMT)
    if(hour >= 13 && hour < 22 && TradeInNewYork) return true;
    
    // é‡å æ—¶æ®µæ€»æ˜¯å…è®¸
    if(hour >= 13 && hour < 16) return true;
    
    return true; // é»˜è®¤å…è®¸äº¤æ˜“
}

//+------------------------------------------------------------------+
//| åˆå§‹åŒ–å…ƒå­¦ä¹ å™¨                                                    |
//+------------------------------------------------------------------+
void InitializeMetaLearner() {
    // æ›´æ¿€è¿›çš„åˆå§‹åŒ–
    for(int i = 0; i < 400; i++) {
        model.weights[i] = (MathRand() % 200 - 100) / 100.0; // -1åˆ°1ä¹‹é—´
    }
    
    for(int i = 0; i < 20; i++) {
        model.bias[i] = (MathRand() % 100 - 50) / 100.0;
    }
    
    model.performance_score = 0.0;
    model.is_trained = false;
    model.confidence_level = 0.5;
    
    Print("ğŸ§  Aggressive Meta-learner initialized");
}

//+------------------------------------------------------------------+
//| æå–å¢å¼ºå¸‚åœºç‰¹å¾                                                  |
//+------------------------------------------------------------------+
MarketMicrostructure ExtractEnhancedFeatures() {
    MarketMicrostructure features;
    
    // è·å–ä»·æ ¼æ•°æ®
    double close[], high[], low[];
    long volume[];
    
    if(CopyClose(_Symbol, PERIOD_CURRENT, 0, 50, close) < 0 ||
       CopyHigh(_Symbol, PERIOD_CURRENT, 0, 50, high) < 0 ||
       CopyLow(_Symbol, PERIOD_CURRENT, 0, 50, low) < 0 ||
       CopyTickVolume(_Symbol, PERIOD_CURRENT, 0, 50, volume) < 0) {
        Print("Error copying enhanced market data");
        return features;
    }
    
    int size = ArraySize(close);
    if(size < 10) return features;
    
    // ä»·æ ¼å˜åŒ–å’ŒåŠ¨é‡
    features.price_change = (close[size-1] - close[size-2]) / close[size-2];
    features.momentum = (close[size-1] - close[size-5]) / close[size-5]; // 5å‘¨æœŸåŠ¨é‡
    
    // æˆäº¤é‡åˆ†æ
    features.volume_change = (double)(volume[size-1] - volume[size-2]);
    
    // å¢å¼ºæ³¢åŠ¨ç‡è®¡ç®—
    double sum = 0;
    for(int i = size-20; i < size-1; i++) {
        double change = (close[i] - close[i-1]) / close[i-1];
        sum += change * change;
    }
    features.volatility = MathSqrt(sum / 19) * VolatilityMultiplier;
    
    // RSI (è¶…ä¹°è¶…å–)
    double rsi_buffer[];
    if(CopyBuffer(rsi_handle, 0, 0, 1, rsi_buffer) > 0) {
        features.rsi = (rsi_buffer[0] - 50.0) / 50.0; // æ ‡å‡†åŒ–åˆ°-1åˆ°1
    }
    
    // MACDä¿¡å·
    double macd_main[], macd_signal[];
    if(CopyBuffer(macd_handle, 0, 0, 1, macd_main) > 0 &&
       CopyBuffer(macd_handle, 1, 0, 1, macd_signal) > 0) {
        features.macd = (macd_main[0] - macd_signal[0]) * 10000; // æ”¾å¤§ä¿¡å·
    }
    
    // ATR (çœŸå®æ³¢å¹…)
    double atr_buffer[];
    if(CopyBuffer(atr_handle, 0, 0, 1, atr_buffer) > 0) {
        features.atr = atr_buffer[0] / close[size-1]; // æ ‡å‡†åŒ–
    }
    
    // å¸ƒæ—å¸¦ä½ç½®
    double bb_upper[], bb_lower[], bb_middle[];
    if(CopyBuffer(bb_handle, 1, 0, 1, bb_upper) > 0 &&
       CopyBuffer(bb_handle, 2, 0, 1, bb_lower) > 0 &&
       CopyBuffer(bb_handle, 0, 0, 1, bb_middle) > 0) {
        double bb_width = bb_upper[0] - bb_lower[0];
        if(bb_width > 0) {
            features.bb_position = (close[size-1] - bb_lower[0]) / bb_width - 0.5; // -0.5åˆ°0.5
        }
    }
    
    // è¶‹åŠ¿å¼ºåº¦
    double ma_fast[], ma_slow[];
    if(CopyBuffer(ma_fast_handle, 0, 0, 1, ma_fast) > 0 &&
       CopyBuffer(ma_slow_handle, 0, 0, 1, ma_slow) > 0) {
        features.trend_strength = (ma_fast[0] - ma_slow[0]) / ma_slow[0] * 1000;
    }
    
    // ç‚¹å·®æˆæœ¬
    MqlTick tick;
    if(SymbolInfoTick(_Symbol, tick)) {
        features.spread = (tick.ask - tick.bid) / tick.bid * 10000;
    }
    
    return features;
}

//+------------------------------------------------------------------+
//| æ„å»ºå¢å¼ºè¾“å…¥å‘é‡                                                  |
//+------------------------------------------------------------------+
SimpleVector BuildEnhancedInput(MarketMicrostructure& features) {
    SimpleVector input_vector;
    input_vector.size = 10;
    
    input_vector.data[0] = features.price_change * 1000;  // æ”¾å¤§å°æ•°
    input_vector.data[1] = features.volume_change / 1000; // ç¼©æ”¾æˆäº¤é‡
    input_vector.data[2] = features.volatility * 100;
    input_vector.data[3] = features.rsi;
    input_vector.data[4] = features.macd;
    input_vector.data[5] = features.spread;
    input_vector.data[6] = features.atr * 1000;
    input_vector.data[7] = features.momentum * 1000;
    input_vector.data[8] = features.bb_position * 2;
    input_vector.data[9] = features.trend_strength;
    
    return input_vector;
}

//+------------------------------------------------------------------+
//| å¢å¼ºç¥ç»ç½‘ç»œå‰å‘ä¼ æ’­                                              |
//+------------------------------------------------------------------+
SimpleVector EnhancedTransformerForward(SimpleVector& input_data) {
    SimpleVector output;
    output.size = 3; // ä¹°å…¥ã€å–å‡ºã€æŒæœ‰æ¦‚ç‡
    
    // ç¬¬ä¸€å±‚è®¡ç®—
    double hidden[10];
    for(int i = 0; i < 10; i++) {
        double sum = model.bias[i];
        for(int j = 0; j < input_data.size; j++) {
            sum += input_data.data[j] * model.weights[i * input_data.size + j];
        }
        hidden[i] = MathTanh(sum); // tanhæ¿€æ´»å‡½æ•°
    }
    
    // ç¬¬äºŒå±‚è®¡ç®— (è¾“å‡ºå±‚)
    for(int i = 0; i < 3; i++) {
        double sum = model.bias[10 + i];
        for(int j = 0; j < 10; j++) {
            sum += hidden[j] * model.weights[100 + i * 10 + j];
        }
        output.data[i] = 1.0 / (1.0 + MathExp(-sum)); // sigmoidæ¿€æ´»
    }
    
    // å½’ä¸€åŒ–è¾“å‡º
    double total = output.data[0] + output.data[1] + output.data[2];
    if(total > 0) {
        output.data[0] /= total;
        output.data[1] /= total;
        output.data[2] /= total;
    }
    
    return output;
}

//+------------------------------------------------------------------+
//| ç”Ÿæˆæ¿€è¿›äº¤æ˜“ä¿¡å·                                                  |
//+------------------------------------------------------------------+
void GenerateAggressiveSignals() {
    if(!modelTrained) {
        Print("âš ï¸ Model not trained, skipping signal generation");
        return;
    }
    
    static int signal_count = 0;
    signal_count++;
    
    // æå–å¢å¼ºç‰¹å¾
    MarketMicrostructure features = ExtractEnhancedFeatures();
    
    if(signal_count % 100 == 0) { // æ¯100æ¬¡æ‰“å°ä¸€æ¬¡ç‰¹å¾
        Print("ğŸ“Š Features - Price:", DoubleToString(features.price_change*1000,2), 
              " Vol:", DoubleToString(features.volatility*100,4), 
              " RSI:", DoubleToString(features.rsi,3));
    }
    
    // æ„å»ºè¾“å…¥
    SimpleVector data_input = BuildEnhancedInput(features);
    
    // è·å–é¢„æµ‹
    SimpleVector prediction = EnhancedTransformerForward(data_input);
    
    double buy_signal = prediction.data[0];
    double sell_signal = prediction.data[1];
    double hold_signal = prediction.data[2];
    
    // å¤§å¹…é™ä½ä¿¡å·é˜ˆå€¼ä½¿å…¶æ›´å®¹æ˜“è§¦å‘äº¤æ˜“
    double current_threshold = 0.35; // ä»0.55é™åˆ°0.35
    
    // é‡å æ—¶æ®µè¿›ä¸€æ­¥é™ä½é˜ˆå€¼
    MqlDateTime dt;
    TimeToStruct(TimeCurrent(), dt);
    if(dt.hour >= 8 && dt.hour < 22) { // ä¸»è¦äº¤æ˜“æ—¶æ®µ
        current_threshold = 0.30; // æ›´ä½é˜ˆå€¼
    }
    
    // é«˜æ³¢åŠ¨æœŸé™ä½é˜ˆå€¼
    if(features.volatility > 0.0001) {
        current_threshold = 0.25; // æä½é˜ˆå€¼
    }
    
    // å®šæœŸå¼ºåˆ¶äº¤æ˜“ä»¥æµ‹è¯•ç³»ç»Ÿ
    static int force_trade_counter = 0;
    force_trade_counter++;
    
    if(force_trade_counter % 500 == 0 && CountPositions() == 0) {
        Print("ğŸ”¥ FORCE TRADE TEST - Buy signal:", DoubleToString(buy_signal,3), 
              " Sell signal:", DoubleToString(sell_signal,3));
        if(buy_signal >= sell_signal) {
            ExecuteAggressiveBuy(BaseLotSize, 0.8);
            return;
        } else {
            ExecuteAggressiveSell(BaseLotSize, 0.8);
            return;
        }
    }
    
    // è®¡ç®—åŠ¨æ€æ‰‹æ•°
    double lot_size = CalculateDynamicLotSize(MathMax(buy_signal, sell_signal));
    
    // æ£€æŸ¥å½“å‰æŒä»“
    int current_positions = CountPositions();
    
    if(signal_count % 50 == 0) { // å®šæœŸæ‰“å°ä¿¡å·çŠ¶æ€
        Print("ğŸ¯ Signals - Buy:", DoubleToString(buy_signal,3), 
              " Sell:", DoubleToString(sell_signal,3), 
              " Threshold:", DoubleToString(current_threshold,3),
              " Positions:", current_positions);
    }
    
    // æ¿€è¿›äº¤æ˜“é€»è¾‘
    if (buy_signal > current_threshold && buy_signal > sell_signal && 
        current_positions < MaxPositions) {
        
        // é«˜ä¿¡å¿ƒä¿¡å·ä½¿ç”¨æ›´å¤§æ‰‹æ•°
        if(buy_signal > ConfidenceBoost) {
            lot_size *= 1.5;
        }
        
        Print("ğŸš€ BUY SIGNAL TRIGGERED! Signal:", DoubleToString(buy_signal,3), " Threshold:", DoubleToString(current_threshold,3));
        ExecuteAggressiveBuy(lot_size, buy_signal);
        
    } else if (sell_signal > current_threshold && sell_signal > buy_signal && 
               current_positions < MaxPositions) {
        
        // é«˜ä¿¡å¿ƒä¿¡å·ä½¿ç”¨æ›´å¤§æ‰‹æ•°
        if(sell_signal > ConfidenceBoost) {
            lot_size *= 1.5;
        }
        
        Print("ğŸš€ SELL SIGNAL TRIGGERED! Signal:", DoubleToString(sell_signal,3), " Threshold:", DoubleToString(current_threshold,3));
        ExecuteAggressiveSell(lot_size, sell_signal);
    }
    
    // å‰¥å¤´çš®æœºä¼š - é™ä½é˜ˆå€¼
    if(UseScalping && features.volatility > 0.0001) {
        CheckScalpingOpportunities(prediction);
    }
}

//+------------------------------------------------------------------+
//| è®¡ç®—åŠ¨æ€æ‰‹æ•°                                                      |
//+------------------------------------------------------------------+
double CalculateDynamicLotSize(double signal_strength) {
    double account_balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk_amount = account_balance * RiskPerTrade;
    
    // åŸºç¡€æ‰‹æ•°
    double lot_size = BaseLotSize;
    
    // æ ¹æ®ä¿¡å·å¼ºåº¦è°ƒæ•´
    lot_size *= (0.5 + signal_strength);
    
    // æ ¹æ®è¿èƒœè¿è´¥è°ƒæ•´
    if(model.consecutive_wins >= 3) {
        lot_size *= 1.2; // è¿èƒœæ—¶åŠ å¤§æ‰‹æ•°
    }
    if(model.consecutive_losses >= 2 && UseMartin) {
        lot_size *= MathPow(MartinMultiplier, model.consecutive_losses); // é©¬ä¸ç­–ç•¥
    }
    
    // é™åˆ¶æœ€å¤§æ‰‹æ•°
    lot_size = MathMin(lot_size, MaxLotSize);
    
    // ç¡®ä¿æœ€å°æ‰‹æ•°
    double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    lot_size = MathMax(lot_size, min_lot);
    
    return lot_size;
}

//+------------------------------------------------------------------+
//| æ‰§è¡Œæ¿€è¿›ä¹°å…¥                                                      |
//+------------------------------------------------------------------+
void ExecuteAggressiveBuy(double lots, double confidence) {
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return;
    
    // åŠ¨æ€æ­¢æŸæ­¢ç›ˆ
    double atr_value = GetATRValue();
    double sl = tick.ask - atr_value * 1.5; // è¾ƒå°æ­¢æŸ
    double tp = tick.ask + atr_value * 3.0; // è¾ƒå¤§æ­¢ç›ˆ
    
    // é«˜ä¿¡å¿ƒäº¤æ˜“ä½¿ç”¨æ›´æ¿€è¿›çš„æ­¢æŸæ­¢ç›ˆ
    if(confidence > ConfidenceBoost) {
        sl = tick.ask - atr_value * 1.0; // æ›´å°æ­¢æŸ
        tp = tick.ask + atr_value * 4.0; // æ›´å¤§æ­¢ç›ˆ
    }
    
    string comment = StringFormat("AggressiveBuy_%.2f_%.0f%%", lots, confidence*100);
    
    if(trade.Buy(lots, _Symbol, tick.ask, sl, tp, comment)) {
        trade_manager.trades_today++;
        trade_manager.current_lot_size = lots;
        Print("ğŸ”¥ Aggressive BUY executed: ", lots, " lots, confidence: ", 
              DoubleToString(confidence*100, 1), "%");
    } else {
        Print("âŒ Buy order failed: ", trade.ResultRetcode(), " - ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| æ‰§è¡Œæ¿€è¿›å–å‡º                                                      |
//+------------------------------------------------------------------+
void ExecuteAggressiveSell(double lots, double confidence) {
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return;
    
    // åŠ¨æ€æ­¢æŸæ­¢ç›ˆ
    double atr_value = GetATRValue();
    double sl = tick.bid + atr_value * 1.5; // è¾ƒå°æ­¢æŸ
    double tp = tick.bid - atr_value * 3.0; // è¾ƒå¤§æ­¢ç›ˆ
    
    // é«˜ä¿¡å¿ƒäº¤æ˜“ä½¿ç”¨æ›´æ¿€è¿›çš„æ­¢æŸæ­¢ç›ˆ
    if(confidence > ConfidenceBoost) {
        sl = tick.bid + atr_value * 1.0; // æ›´å°æ­¢æŸ
        tp = tick.bid - atr_value * 4.0; // æ›´å¤§æ­¢ç›ˆ
    }
    
    string comment = StringFormat("AggressiveSell_%.2f_%.0f%%", lots, confidence*100);
    
    if(trade.Sell(lots, _Symbol, tick.bid, sl, tp, comment)) {
        trade_manager.trades_today++;
        trade_manager.current_lot_size = lots;
        Print("ğŸ”¥ Aggressive SELL executed: ", lots, " lots, confidence: ", 
              DoubleToString(confidence*100, 1), "%");
    } else {
        Print("âŒ Sell order failed: ", trade.ResultRetcode(), " - ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| è·å–ATRå€¼                                                        |
//+------------------------------------------------------------------+
double GetATRValue() {
    double atr_buffer[];
    if(CopyBuffer(atr_handle, 0, 0, 1, atr_buffer) > 0) {
        return atr_buffer[0];
    }
    return _Point * 100; // é»˜è®¤å€¼
}

//+------------------------------------------------------------------+
//| æ£€æŸ¥å‰¥å¤´çš®æœºä¼š                                                    |
//+------------------------------------------------------------------+
void CheckScalpingOpportunities(SimpleVector& prediction) {
    if(CountPositions() >= MaxPositions) return;
    
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return;
    
    double spread = (tick.ask - tick.bid) / _Point;
    if(spread > 5) return; // æ”¾å®½ç‚¹å·®é™åˆ¶
    
    double buy_prob = prediction.data[0];
    double sell_prob = prediction.data[1];
    
    // å‰¥å¤´çš®ä¿¡å·ï¼ˆæ›´ä½é˜ˆå€¼ï¼‰
    if(buy_prob > 0.45 && buy_prob > sell_prob) { // ä»0.52é™åˆ°0.45
        double tp = tick.ask + ScalpingProfit * _Point;
        double sl = tick.ask - ScalpingProfit * _Point * 1.2; // ç¨å¤§æ­¢æŸ
        
        if(trade.Buy(BaseLotSize * 0.5, _Symbol, tick.ask, sl, tp, "Scalp_Buy")) {
            Print("âš¡ Scalping BUY executed: ", ScalpingProfit, " pips target, prob: ", DoubleToString(buy_prob,3));
        } else {
            Print("âŒ Scalping BUY failed: ", trade.ResultRetcode());
        }
    }
    else if(sell_prob > 0.45 && sell_prob > buy_prob) { // ä»0.52é™åˆ°0.45
        double tp = tick.bid - ScalpingProfit * _Point;
        double sl = tick.bid + ScalpingProfit * _Point * 1.2; // ç¨å¤§æ­¢æŸ
        
        if(trade.Sell(BaseLotSize * 0.5, _Symbol, tick.bid, sl, tp, "Scalp_Sell")) {
            Print("âš¡ Scalping SELL executed: ", ScalpingProfit, " pips target, prob: ", DoubleToString(sell_prob,3));
        } else {
            Print("âŒ Scalping SELL failed: ", trade.ResultRetcode());
        }
    }
}

//+------------------------------------------------------------------+
//| ç®¡ç†æŒä»“                                                          |
//+------------------------------------------------------------------+
void ManagePositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(PositionGetSymbol(i) != _Symbol) continue;
        if(PositionGetInteger(POSITION_MAGIC) != magic_number) continue;
        
        double position_profit = PositionGetDouble(POSITION_PROFIT);
        double position_lots = PositionGetDouble(POSITION_VOLUME);
        ENUM_POSITION_TYPE pos_type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        // ç§»åŠ¨æ­¢æŸåˆ°ç›ˆäºå¹³è¡¡
        MoveToBreakeven(PositionGetInteger(POSITION_TICKET), pos_type);
        
        // è¿½è¸ªæ­¢æŸ
        TrailingStop(PositionGetInteger(POSITION_TICKET), pos_type);
        
        // éƒ¨åˆ†å¹³ä»“è·åˆ©
        if(position_profit > AccountInfoDouble(ACCOUNT_BALANCE) * 0.02) { // 2%ç›ˆåˆ©
            PartialClose(PositionGetInteger(POSITION_TICKET), 0.5); // å¹³ä»“ä¸€åŠ
        }
    }
}

//+------------------------------------------------------------------+
//| ç§»åŠ¨åˆ°ç›ˆäºå¹³è¡¡                                                    |
//+------------------------------------------------------------------+
void MoveToBreakeven(ulong ticket, ENUM_POSITION_TYPE pos_type) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double current_sl = PositionGetDouble(POSITION_SL);
    double profit = PositionGetDouble(POSITION_PROFIT);
    
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return;
    
    // ç›ˆåˆ©è¶³å¤Ÿæ—¶ç§»åŠ¨åˆ°ç›ˆäºå¹³è¡¡
    if(pos_type == POSITION_TYPE_BUY && tick.bid > open_price + GetATRValue() * 1.0) {
        if(current_sl < open_price) {
            trade.PositionModify(ticket, open_price + _Point * 5, PositionGetDouble(POSITION_TP));
            Print("ğŸ“ˆ Moved BUY SL to breakeven for ticket: ", ticket);
        }
    }
    else if(pos_type == POSITION_TYPE_SELL && tick.ask < open_price - GetATRValue() * 1.0) {
        if(current_sl > open_price) {
            trade.PositionModify(ticket, open_price - _Point * 5, PositionGetDouble(POSITION_TP));
            Print("ğŸ“‰ Moved SELL SL to breakeven for ticket: ", ticket);
        }
    }
}

//+------------------------------------------------------------------+
//| è¿½è¸ªæ­¢æŸ                                                          |
//+------------------------------------------------------------------+
void TrailingStop(ulong ticket, ENUM_POSITION_TYPE pos_type) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double current_sl = PositionGetDouble(POSITION_SL);
    double atr_value = GetATRValue();
    
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) return;
    
    if(pos_type == POSITION_TYPE_BUY) {
        double new_sl = tick.bid - atr_value * 1.5;
        if(new_sl > current_sl + _Point * 10) { // è‡³å°‘ç§»åŠ¨10ç‚¹
            trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP));
            Print("ğŸ”„ Trailing BUY SL updated to: ", new_sl);
        }
    }
    else if(pos_type == POSITION_TYPE_SELL) {
        double new_sl = tick.ask + atr_value * 1.5;
        if(new_sl < current_sl - _Point * 10) { // è‡³å°‘ç§»åŠ¨10ç‚¹
            trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP));
            Print("ğŸ”„ Trailing SELL SL updated to: ", new_sl);
        }
    }
}

//+------------------------------------------------------------------+
//| éƒ¨åˆ†å¹³ä»“                                                          |
//+------------------------------------------------------------------+
void PartialClose(ulong ticket, double close_ratio) {
    if(!PositionSelectByTicket(ticket)) return;
    
    double position_volume = PositionGetDouble(POSITION_VOLUME);
    double close_volume = NormalizeDouble(position_volume * close_ratio, 2);
    
    if(close_volume >= SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN)) {
        if(trade.PositionClosePartial(ticket, close_volume)) {
            Print("ğŸ’° Partial close: ", close_volume, " lots closed from ticket: ", ticket);
        }
    }
}

//+------------------------------------------------------------------+
//| è®¡ç®—æŒä»“æ•°é‡                                                      |
//+------------------------------------------------------------------+
int CountPositions() {
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        if(PositionGetSymbol(i) == _Symbol && 
           PositionGetInteger(POSITION_MAGIC) == magic_number) {
            count++;
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| å…³é—­äºæŸæŒä»“                                                      |
//+------------------------------------------------------------------+
void CloseLosingPositions() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(PositionGetSymbol(i) != _Symbol) continue;
        if(PositionGetInteger(POSITION_MAGIC) != magic_number) continue;
        
        double position_profit = PositionGetDouble(POSITION_PROFIT);
        if(position_profit < 0) {
            ulong ticket = PositionGetInteger(POSITION_TICKET);
            if(trade.PositionClose(ticket)) {
                Print("âŒ Closed losing position: ", ticket, " P&L: ", position_profit);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| è®­ç»ƒæ¨¡å‹ï¼ˆæ¿€è¿›ç‰ˆæœ¬ï¼‰                                              |
//+------------------------------------------------------------------+
void TrainModel() {
    Print("ğŸ§  Starting AGGRESSIVE model training...");
    
    if(!CollectTrainingData()) {
        Print("Failed to collect training data");
        return;
    }
    
    // æ¿€è¿›çš„MAMLè®­ç»ƒ
    AggressiveMAMLTraining();
    
    // ä¿å­˜è®­ç»ƒå¥½çš„æ¨¡å‹
    if(SaveModel()) {
        modelTrained = true;
        Print("ğŸ¯ AGGRESSIVE model training completed and saved");
    }
}

//+------------------------------------------------------------------+
//| æ¿€è¿›MAMLè®­ç»ƒ                                                     |
//+------------------------------------------------------------------+
void AggressiveMAMLTraining() {
    Print("ğŸš€ Starting AGGRESSIVE MAML training...");
    
    int num_tasks = 8;        // æ›´å¤šä»»åŠ¡
    int meta_iterations = 15;  // æ›´å¤šè¿­ä»£
    
    for (int meta_iter = 0; meta_iter < meta_iterations; meta_iter++) {
        double meta_loss_sum = 0;
        
        for (int task = 0; task < num_tasks; task++) {
            // ä¿å­˜åŸå§‹æ¨¡å‹
            double original_weights[400];
            for(int i = 0; i < 400; i++) {
                original_weights[i] = model.weights[i];
            }
            
            // å†…å±‚å¿«é€Ÿé€‚åº”ï¼ˆæ›´å¤šæ­¥éª¤ï¼‰
            for (int inner_step = 0; inner_step < 8; inner_step++) {
                double task_loss = CalculateAdvancedTaskLoss(task);
                UpdateWeightsAggressive(task_loss, 0.02); // æ›´å¤§çš„å­¦ä¹ ç‡
            }
            
            // è®¡ç®—ä»»åŠ¡æŸå¤±
            double task_meta_loss = EvaluateAdvancedPerformance();
            meta_loss_sum += task_meta_loss;
            
            // æ¢å¤åŸå§‹æ¨¡å‹
            for(int i = 0; i < 400; i++) {
                model.weights[i] = original_weights[i];
            }
        }
        
        // æ›´æ–°å…ƒæ¨¡å‹
        double meta_loss = meta_loss_sum / num_tasks;
        UpdateWeightsAggressive(meta_loss, 0.005); // å…ƒå­¦ä¹ ç‡
        
        // æ›´æ–°ç½®ä¿¡åº¦
        model.confidence_level = 1.0 - meta_loss;
        if(model.confidence_level > 0.9) model.confidence_level = 0.9;
        if(model.confidence_level < 0.1) model.confidence_level = 0.1;
        
        if(meta_iter % 3 == 0) {
            Print("ğŸ”¥ MAML Iteration ", meta_iter, " Loss: ", 
                  DoubleToString(meta_loss, 6), " Confidence: ", 
                  DoubleToString(model.confidence_level, 3));
        }
    }
    
    Print("ğŸ¯ AGGRESSIVE MAML training completed!");
}

//+------------------------------------------------------------------+
//| é«˜çº§ä»»åŠ¡æŸå¤±è®¡ç®—                                                  |
//+------------------------------------------------------------------+
double CalculateAdvancedTaskLoss(int task) {
    double loss = 0;
    int correct_predictions = 0;
    int total_predictions = 0;
    
    // è·å–å†å²æ•°æ®
    double close[], high[], low[];
    if(CopyClose(_Symbol, PERIOD_CURRENT, task * 20, 50, close) <= 0 ||
       CopyHigh(_Symbol, PERIOD_CURRENT, task * 20, 50, high) <= 0 ||
       CopyLow(_Symbol, PERIOD_CURRENT, task * 20, 50, low) <= 0) {
        return MathRand() % 1000 * 0.001;
    }
    
    // æ¨¡æ‹Ÿé¢„æµ‹å’ŒéªŒè¯
    for(int i = 10; i < ArraySize(close) - 5; i++) {
        // æå–ç‰¹å¾
        MarketMicrostructure features;
        features.price_change = (close[i] - close[i-1]) / close[i-1];
        features.volatility = MathAbs(high[i] - low[i]) / close[i];
        features.momentum = (close[i] - close[i-5]) / close[i-5];
        
        SimpleVector input_vec = BuildEnhancedInput(features);
        SimpleVector prediction = EnhancedTransformerForward(input_vec);
        
        // å®é™…ç»“æœï¼ˆæœªæ¥5å‘¨æœŸçš„ä»·æ ¼å˜åŒ–ï¼‰
        double future_change = (close[i+5] - close[i]) / close[i];
        
        // è®¡ç®—é¢„æµ‹å‡†ç¡®æ€§
        double predicted_direction = prediction.data[0] - prediction.data[1]; // ä¹°-å–
        
        if((future_change > 0 && predicted_direction > 0) || 
           (future_change < 0 && predicted_direction < 0)) {
            correct_predictions++;
        }
        total_predictions++;
        
        // è®¡ç®—MSEæŸå¤±
        double target_buy = future_change > 0 ? 1.0 : 0.0;
        double target_sell = future_change < 0 ? 1.0 : 0.0;
        
        loss += MathPow(prediction.data[0] - target_buy, 2);
        loss += MathPow(prediction.data[1] - target_sell, 2);
    }
    
    if(total_predictions > 0) {
        loss = loss / (total_predictions * 2);
        double accuracy = (double)correct_predictions / total_predictions;
        loss += (1.0 - accuracy); // å‡†ç¡®ç‡æŸå¤±
    }
    
    return loss;
}

//+------------------------------------------------------------------+
//| é«˜çº§æ€§èƒ½è¯„ä¼°                                                      |
//+------------------------------------------------------------------+
double EvaluateAdvancedPerformance() {
    double performance = 0;
    int winning_trades = 0;
    int total_trades = 0;
    
    // è·å–æœ€è¿‘äº¤æ˜“æ•°æ®
    double close[];
    if(CopyClose(_Symbol, PERIOD_CURRENT, 0, 100, close) <= 0) {
        return MathRand() % 1000 * 0.001;
    }
    
    // æ¨¡æ‹Ÿäº¤æ˜“æµ‹è¯•
    for(int i = 20; i < ArraySize(close) - 10; i++) {
        MarketMicrostructure features;
        features.price_change = (close[i] - close[i-1]) / close[i-1];
        features.volatility = CalculateVolatility(close, i, 10);
        features.momentum = (close[i] - close[i-10]) / close[i-10];
        
        SimpleVector input_vec = BuildEnhancedInput(features);
        SimpleVector prediction = EnhancedTransformerForward(input_vec);
        
        // æ¨¡æ‹Ÿäº¤æ˜“å†³ç­–
        if(prediction.data[0] > 0.6) { // ä¹°å…¥ä¿¡å·
            double entry_price = close[i];
            double exit_price = close[i + 5]; // æŒæœ‰5å‘¨æœŸ
            if(exit_price > entry_price) winning_trades++;
            total_trades++;
        }
        else if(prediction.data[1] > 0.6) { // å–å‡ºä¿¡å·
            double entry_price = close[i];
            double exit_price = close[i + 5];
            if(exit_price < entry_price) winning_trades++;
            total_trades++;
        }
    }
    
    if(total_trades > 0) {
        double win_rate = (double)winning_trades / total_trades;
        performance = win_rate;
    } else {
        performance = 0.5; // é»˜è®¤50%
    }
    
    return 1.0 - performance; // è¿”å›æŸå¤±
}

//+------------------------------------------------------------------+
//| è®¡ç®—æ³¢åŠ¨ç‡                                                        |
//+------------------------------------------------------------------+
double CalculateVolatility(double &prices[], int index, int period) {
    if(index < period) return 0;
    
    double sum = 0;
    for(int i = index - period + 1; i <= index; i++) {
        double change = (prices[i] - prices[i-1]) / prices[i-1];
        sum += change * change;
    }
    
    return MathSqrt(sum / period);
}

//+------------------------------------------------------------------+
//| æ¿€è¿›æƒé‡æ›´æ–°                                                      |
//+------------------------------------------------------------------+
void UpdateWeightsAggressive(double loss, double learning_rate) {
    // æ›´æ¿€è¿›çš„æ¢¯åº¦ä¸‹é™
    for(int i = 0; i < 400; i++) {
        // æ¨¡æ‹Ÿæ¢¯åº¦ï¼ˆå®é™…åº”ç”¨ä¸­åº”è¯¥æ˜¯åå‘ä¼ æ’­è®¡ç®—çš„æ¢¯åº¦ï¼‰
        double gradient = (MathRand() % 200 - 100) / 100.0 * loss;
        
        // æ·»åŠ åŠ¨é‡é¡¹
        momentum_weights[i] = 0.9 * momentum_weights[i] + learning_rate * gradient;
        
        model.weights[i] -= momentum_weights[i];
        
        // æ›´å®½æ¾çš„æƒé‡è£å‰ª
        if(model.weights[i] > 20.0) model.weights[i] = 20.0;
        if(model.weights[i] < -20.0) model.weights[i] = -20.0;
    }
    
    // æ›´æ–°åç½®
    for(int i = 0; i < 20; i++) {
        double bias_gradient = (MathRand() % 100 - 50) / 100.0 * loss;
        model.bias[i] -= learning_rate * bias_gradient;
        
        if(model.bias[i] > 10.0) model.bias[i] = 10.0;
        if(model.bias[i] < -10.0) model.bias[i] = -10.0;
    }
}

//+------------------------------------------------------------------+
//| æ”¶é›†è®­ç»ƒæ•°æ®                                                      |
//+------------------------------------------------------------------+
bool CollectTrainingData() {
    Print("ğŸ“Š Collecting AGGRESSIVE training data...");
    
    double rates[];
    int copied = CopyClose(_Symbol, PERIOD_CURRENT, 0, HistoryBars, rates);
    
    if(copied <= 0) {
        Print("Failed to copy historical data");
        return false;
    }
    
    Print("âœ… Collected ", copied, " data points for AGGRESSIVE training");
    return true;
}

//+------------------------------------------------------------------+
//| ä¿å­˜æ¨¡å‹                                                          |
//+------------------------------------------------------------------+
bool SaveModel() {
    Print("ğŸ’¾ Saving AGGRESSIVE model...");
    
    string filename = "AggressiveMetaModel_" + _Symbol + ".bin";
    int handle = FileOpen(filename, FILE_WRITE | FILE_BIN);
    
    if (handle == INVALID_HANDLE) {
        Print("Model saving failed: ", GetLastError());
        return false;
    }
    
    // ä¿å­˜æ¨¡å‹å‚æ•°
    FileWriteDouble(handle, model.performance_score);
    FileWriteInteger(handle, modelTrained ? 1 : 0);
    FileWriteInteger(handle, 400); // æƒé‡æ•°é‡
    FileWriteInteger(handle, model.consecutive_wins);
    FileWriteInteger(handle, model.consecutive_losses);
    FileWriteDouble(handle, model.confidence_level);
    
    // ä¿å­˜æƒé‡
    for(int i = 0; i < 400; i++) {
        FileWriteDouble(handle, model.weights[i]);
    }
    
    // ä¿å­˜åç½®
    for(int i = 0; i < 20; i++) {
        FileWriteDouble(handle, model.bias[i]);
    }
    
    FileClose(handle);
    Print("âœ… AGGRESSIVE model saved successfully to ", filename);
    return true;
}

//+------------------------------------------------------------------+
//| åŠ è½½æ¨¡å‹                                                          |
//+------------------------------------------------------------------+
bool LoadModel() {
    Print("ğŸ“‚ Loading AGGRESSIVE model...");
    
    string filename = "AggressiveMetaModel_" + _Symbol + ".bin";
    int handle = FileOpen(filename, FILE_READ | FILE_BIN);
    
    if (handle == INVALID_HANDLE) {
        Print("Model loading failed - file not found");
        return false;
    }
    
    // åŠ è½½æ¨¡å‹å‚æ•°
    model.performance_score = FileReadDouble(handle);
    modelTrained = (FileReadInteger(handle) == 1);
    int weights_count = FileReadInteger(handle);
    model.consecutive_wins = FileReadInteger(handle);
    model.consecutive_losses = FileReadInteger(handle);
    model.confidence_level = FileReadDouble(handle);
    
    // æ£€æŸ¥æƒé‡æ•°é‡
    if(weights_count != 400) {
        Print("Model structure mismatch - retraining required");
        FileClose(handle);
        return false;
    }
    
    // åŠ è½½æƒé‡
    for(int i = 0; i < 400; i++) {
        model.weights[i] = FileReadDouble(handle);
    }
    
    // åŠ è½½åç½®
    for(int i = 0; i < 20; i++) {
        model.bias[i] = FileReadDouble(handle);
    }
    
    FileClose(handle);
    Print("âœ… AGGRESSIVE model loaded successfully from ", filename);
    Print("ğŸ¯ Model confidence: ", DoubleToString(model.confidence_level * 100, 1), "%");
    return true;
}
